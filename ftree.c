#include <stdio.h>
// Add your system includes here.
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include "ftree.h"
#include <dirent.h>

/*
 * Recursively generates and returns a ftree rooted at fname at path fname for the inital call by generate_ftree
 * Sets sruct TreeNode's contents, fname, permission based on whether path points to directory, file or link
 * Returns a single TreeNode struct which points to a directory, link or file
 */
struct TreeNode *make_ftree(const char *fname, char *path) {
    // Allocate space for a new struct TreeNode tnode
    struct TreeNode *tnode = malloc(sizeof(struct TreeNode));
    // Check whether tnode points to NULL or not
    if (tnode == NULL) {
	perror("malloc");
        exit(1);
    }
    // Allocate space for fname and check whether it points to NULL or not
    tnode->fname = malloc(strlen(fname) + 1);
    if (tnode->fname == NULL) {
	perror("malloc");
        exit(1);
    }
    // Initially declare the contents and next to NULL
    tnode->contents = NULL;
    tnode->next = NULL;
    // Initalize stat buffer and error check whether the path points to an existing file, link or directory or not
    struct stat sb;
    if (lstat(path, &sb) == -1) {
        fprintf(stderr, "The path (%s) does not point to an existing entry!\n", path);
        exit(1);
    }
    // Copy the fname and permissions to struct
    strcpy(tnode->fname, fname);
    strcat(tnode->fname, "\0");
    tnode->permissions = (sb.st_mode & 0777);
    // st.mode points directory recursicely create TreNode and set its type
    if (S_ISDIR(sb.st_mode)) {
        tnode->type = 'd';
	// error check opendir
        DIR *d_ptr = opendir(path);
        if (d_ptr == NULL) {
            perror("opendir");
            exit(1);
        }
	struct dirent *entry_ptr;
        entry_ptr = readdir(d_ptr);
        struct TreeNode *curr;
        struct TreeNode *prev;
        // Connect the linked list using curr and prev and recursiely gererate TreeNode for each file or directory at this level
        while (entry_ptr != NULL) {
            if (entry_ptr->d_name[0] != '.') {
		// Generate a temporary path for recursive call
                char temp[strlen(path) + strlen(entry_ptr->d_name) + 2];
                strcpy(temp, path);
                strcat(temp, "/");
                strcat(temp, entry_ptr->d_name);
                strcat(temp, "\0");
		// Point the contents to first file and recursively create its TreeNode
                if (tnode->contents == NULL) {
                    tnode->contents = make_ftree(entry_ptr->d_name, temp);
                    curr = tnode->contents;
                }
		// Recursive call on each curr and set the value of prev->next to curr to connect the linked list
                else if (tnode->contents != NULL) {
                    prev = curr;
                    curr = make_ftree(entry_ptr->d_name, temp);
                    prev->next = curr;
                }
            }
	    // move the pointer to next file in the directory
            entry_ptr = readdir(d_ptr);
        }
	// close the directory and error check closedir
        if (closedir(d_ptr) == -1) {
		perror("closedir");
		exit(1);
	}
    }
    // Set the value of type based on whether its file or link
    else if (S_ISREG(sb.st_mode)) {
        tnode->type = '-';
    }
    else if (S_ISLNK(sb.st_mode)) {
        tnode->type = 'l';
    }
    return tnode;
}

/*
 * Returns the FTree rooted at the path fname.
 *
 * Use the following if the file fname doesn't exist and return NULL:
 * fprintf(stderr, "The path (%s) does not point to an existing entry!\n", fname);
 *
 */
struct TreeNode *generate_ftree(const char *fname) {
    struct stat sb;
    // Create a path for fname to be passed in make_ftree
    char path[strlen(fname) + 1];
    strcpy(path, fname);
    strcat(path, "\0");
    // Check whether fname points to actual file, directory or link or not
    if (lstat(path, &sb) == -1) {
        fprintf(stderr, "The path (%s) does not point to an existing entry!\n", path);
        exit(1);
    }
    //Create a TreeNode root and point it to a TreeNode generated by fname
    struct TreeNode *root = make_ftree(fname, path);
    return root;
}

/*
 * Prints the TreeNodes encountered on a preorder traversal of an FTree.
 *
 * The only print statements that you may use in this function are:
 * printf("===== %s (%c%o) =====\n", root->fname, root->type, root->permissions)
 * printf("%s (%c%o)\n", root->fname, root->type, root->permissions)
 *
 */
void print_ftree(struct TreeNode *root) {
    // Here's a trick for remembering what depth (in the tree) you're at
    // and printing 2 * that many spaces at the beginning of the line.
    static int depth = 0;
    // Indent space from  right hand side to specify at what level the filr, diectory or link is
    printf("%*s", depth * 2, "");
    // if root points to a directory, print its info accordingly and recursively print its components
    if (root->type == 'd') {
    	printf("===== %s (%c%o) =====\n", root->fname, root->type, root->permissions);
        depth++;
        struct TreeNode *curr = root->contents;
        while (curr != NULL) {
        	print_ftree(curr);
                curr = curr->next;
        }
        depth--;
    }
    else {
        printf("%s (%c%o)\n", root->fname, root->type, root->permissions);
    }
}

/*
 * Deallocate all dynamically-allocated memory in the FTree rooted at node.
 *
 */
void deallocate_ftree (struct TreeNode *node) {
    if (node != NULL) {
	// Recursively free the space allocate to its components if node is a directory
    	if (node->type == 'd') {
		struct TreeNode *curr = node->contents;
		struct TreeNode *prev = node->contents;
		while (curr != NULL) {
			curr = curr->next;
			deallocate_ftree(prev);
			prev = curr;
		}
    	}
    }
    // Free the space allocated to fname in struct and struct TreeNode
    free(node->fname);
    free(node);
}
